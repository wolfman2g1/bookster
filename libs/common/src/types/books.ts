// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v4.25.3
// source: proto/books.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const booksProtobufPackage = "bookapp.books.v1";

/**
 * --------------------
 * Enums
 * --------------------
 */
export enum ExternalSource {
  EXTERNAL_SOURCE_UNSPECIFIED = 0,
  OPEN_LIBRARY = 1,
  GOOGLE_BOOKS = 2,
  OTHER = 3,
  UNRECOGNIZED = -1,
}

export enum ReactionType {
  REACTION_TYPE_UNSPECIFIED = 0,
  LIKE = 1,
  DISLIKE = 2,
  UNRECOGNIZED = -1,
}

export enum ReadingStatus {
  READING_STATUS_UNSPECIFIED = 0,
  WANT = 1,
  READING = 2,
  READ = 3,
  DNF = 4,
  UNRECOGNIZED = -1,
}

/**
 * --------------------
 * Core Models
 * --------------------
 */
export interface Book {
  id: string;
  title: string;
  subtitle: string;
  description: string;
  language: string;
  publishedYear: number;
  coverImageUrl: string;
  externalSource: ExternalSource;
  externalId: string;
  authors: Author[];
  genres: Genre[];
  /**
   * Convenience fields that are useful for search display + ranking.
   * (These can be derived server-side; clients don't need to compute them.)
   */
  primaryAuthor: string;
  /** useful for Meilisearch searchableAttributes */
  authorNames: string[];
  /** useful for Meilisearch filterableAttributes */
  genreSlugs: string[];
  /** Optional stats (for ranking/feeds; server may omit). */
  likeCount: number;
  dislikeCount: number;
  wantCount: number;
  readingCount: number;
  readCount: number;
  dnfCount: number;
  /** ISO-8601 strings for simplicity across languages. */
  createdAt: string;
  updatedAt: string;
}

export interface Author {
  id: string;
  name: string;
  sortName: string;
  externalSource: ExternalSource;
  externalId: string;
  createdAt: string;
  updatedAt: string;
}

export interface Genre {
  id: string;
  name: string;
  slug: string;
  createdAt: string;
  updatedAt: string;
}

export interface UserBookReaction {
  userId: string;
  bookId: string;
  reaction: ReactionType;
  createdAt: string;
  updatedAt: string;
}

export interface UserBookStatus {
  userId: string;
  bookId: string;
  status: ReadingStatus;
  startedAt: string;
  finishedAt: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * --------------------
 * Search
 * --------------------
 */
export interface SearchBooksRequest {
  query: string;
  /** Pagination â€” Meilisearch supports limit/offset style easily. */
  limit: number;
  offset: number;
  /** If local search results are weak/empty, server may query external sources and enqueue imports. */
  allowExternalFallback: boolean;
  /** Filters (map nicely to Meilisearch filterableAttributes) */
  language: string;
  publishedYearMin: number;
  publishedYearMax: number;
  genreSlugs: string[];
  /**
   * Optional: simple sort hints (server decides if supported)
   * Examples: "relevance", "published_year:desc", "like_count:desc"
   */
  sort: string;
}

export interface SearchBooksResponse {
  books: Book[];
  /** Whether the server performed an external fallback request. */
  usedExternalFallback: boolean;
  /** Whether the server queued background imports/upserts for any external hits. */
  importEnqueued: boolean;
  /** Best-effort count for pagination. */
  total: number;
}

/**
 * --------------------
 * Get Book
 * --------------------
 */
export interface GetBookRequest {
  id: string;
  includeStats: boolean;
}

export interface GetBookResponse {
  book: Book | undefined;
}

/**
 * --------------------
 * Upsert Book (Importer/Worker)
 * --------------------
 */
export interface UpsertBookRequest {
  /** Optional internal ID (if known) */
  id: string;
  title: string;
  subtitle: string;
  description: string;
  language: string;
  publishedYear: number;
  coverImageUrl: string;
  externalSource: ExternalSource;
  externalId: string;
  authors: UpsertAuthor[];
  genres: UpsertGenre[];
  /** Optional: if true, server should push/update the search document as part of this call. */
  reindexSearchDocument: boolean;
}

export interface UpsertAuthor {
  id: string;
  name: string;
  sortName: string;
  externalSource: ExternalSource;
  externalId: string;
  /** Join-table-ish fields */
  role: string;
  position: number;
}

export interface UpsertGenre {
  id: string;
  name: string;
  slug: string;
  confidence: number;
}

export interface UpsertBookResponse {
  book: Book | undefined;
  created: boolean;
}

/**
 * --------------------
 * User Reaction
 * --------------------
 */
export interface SetUserBookReactionRequest {
  userId: string;
  bookId: string;
  reaction: ReactionType;
}

export interface SetUserBookReactionResponse {
  reaction: UserBookReaction | undefined;
}

/**
 * --------------------
 * User Status
 * --------------------
 */
export interface SetUserBookStatusRequest {
  userId: string;
  bookId: string;
  status: ReadingStatus;
  startedAt: string;
  finishedAt: string;
}

export interface SetUserBookStatusResponse {
  status: UserBookStatus | undefined;
}

export const BOOKAPP_BOOKS_V1_PACKAGE_NAME = "bookapp.books.v1";

/**
 * --------------------
 * Service
 * --------------------
 */

export interface BooksServiceClient {
  /**
   * Searches books. Server may use a search engine (Meilisearch) and optionally fall back
   * to external sources if local results are weak/empty.
   */

  searchBooks(request: SearchBooksRequest): Observable<SearchBooksResponse>;

  getBook(request: GetBookRequest): Observable<GetBookResponse>;

  /** Upsert a book (used by importers/workers). */

  upsertBook(request: UpsertBookRequest): Observable<UpsertBookResponse>;

  setUserBookReaction(request: SetUserBookReactionRequest): Observable<SetUserBookReactionResponse>;

  setUserBookStatus(request: SetUserBookStatusRequest): Observable<SetUserBookStatusResponse>;
}

/**
 * --------------------
 * Service
 * --------------------
 */

export interface BooksServiceController {
  /**
   * Searches books. Server may use a search engine (Meilisearch) and optionally fall back
   * to external sources if local results are weak/empty.
   */

  searchBooks(
    request: SearchBooksRequest,
  ): Promise<SearchBooksResponse> | Observable<SearchBooksResponse> | SearchBooksResponse;

  getBook(request: GetBookRequest): Promise<GetBookResponse> | Observable<GetBookResponse> | GetBookResponse;

  /** Upsert a book (used by importers/workers). */

  upsertBook(
    request: UpsertBookRequest,
  ): Promise<UpsertBookResponse> | Observable<UpsertBookResponse> | UpsertBookResponse;

  setUserBookReaction(
    request: SetUserBookReactionRequest,
  ): Promise<SetUserBookReactionResponse> | Observable<SetUserBookReactionResponse> | SetUserBookReactionResponse;

  setUserBookStatus(
    request: SetUserBookStatusRequest,
  ): Promise<SetUserBookStatusResponse> | Observable<SetUserBookStatusResponse> | SetUserBookStatusResponse;
}

export function BooksServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["searchBooks", "getBook", "upsertBook", "setUserBookReaction", "setUserBookStatus"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("BooksService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("BooksService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const BOOKS_SERVICE_NAME = "BooksService";
